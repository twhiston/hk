package cmd

// This file was auto generated by the hk code generator
// DO NOT ALTER THIS FILE MANUALLY

import (
	"errors"
	"github.com/spf13/cobra"
	"io/ioutil"
)

var overviewCmd = &cobra.Command{
	Use:     "overview",
	Short:   "Get your current overview",
	Aliases: []string{"stats"},
	Long:    `Returns the /overview endpoint which details your current overtime, percent worked etc....`,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		resp := new(StatsResponse)

		querystring := make(map[string]string)

		if impersonate != "" {
			querystring["user_id"] = impersonate
		}

		res := api.Res("overview", resp)
		r, err := res.Get(querystring)
		HandleError(err)

		if r.Raw.StatusCode != 200 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

		printResponse(*resp)

	},
}

var timerCmd = &cobra.Command{
	Use:   "timer",
	Short: "Control the timer",
	Long:  `Start, stop, delete and view timers with timer subcommands`,
}

var timergetCmd = &cobra.Command{
	Use:   "get",
	Short: "Shows the current timer",
	Long:  `Gets the current timer and displays it's details`,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		resp := new(TimerResponse)

		querystring := make(map[string]string)

		if impersonate != "" {
			querystring["user_id"] = impersonate
		}

		res := api.Res("timer", resp)
		r, err := res.Get(querystring)
		HandleError(err)

		if r.Raw.StatusCode != 200 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

		printResponse(*resp)

	},
}

var timertypesCmd = &cobra.Command{
	Use:   "types",
	Short: "Get the types of timer available",
	Long:  `Returns the possible timer options for your hakuna instance, use these id's with timer commands`,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		resp := new(TimerTypesResponse)

		querystring := make(map[string]string)

		if impersonate != "" {
			querystring["user_id"] = impersonate
		}

		res := api.Res("time_types", resp)
		r, err := res.Get(querystring)
		HandleError(err)

		if r.Raw.StatusCode != 200 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

		printArrayResponse(*resp)

	},
}

var timerstartCmd = &cobra.Command{
	Use:   "start",
	Short: "Starts a new timer",
	Long:  `Creates a new running timer starting from now`,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		resp := new(TimerResponse)

		payload := new(TimerStartPayload)

		// Payload renderer must have signature (cmd *cobra.Command, args []string, payload *TimerStartPayload) (*TimerStartPayload, error)
		err := fillStartTimerData(cmd, args, payload)
		HandleError(err)
		res := api.Res("timer", resp)
		if impersonate != "" {
			querystring := make(map[string]string, 1)
			querystring["user_id"] = impersonate
			res.SetPayload(querystring)
		}
		r, err := res.Post(payload)
		HandleError(err)

		if r.Raw.StatusCode != 201 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

	},
}

var timerstopCmd = &cobra.Command{
	Use:   "stop",
	Short: "Stop the currently running timer",
	Long:  ``,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		resp := new(TimeEntryResponse)

		payload := new(TimerStopPayload)

		res := api.Res("timer", resp)
		if impersonate != "" {
			querystring := make(map[string]string, 1)
			querystring["user_id"] = impersonate
			res.SetPayload(querystring)
		}
		r, err := res.Put(payload)
		HandleError(err)

		if r.Raw.StatusCode != 200 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

		printResponse(*resp)

	},
}

var timercancelCmd = &cobra.Command{
	Use:   "cancel",
	Short: "Cancel a timer",
	Long:  `Deletes the currently running timer`,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		querystring := make(map[string]string)

		if impersonate != "" {
			querystring["user_id"] = impersonate
		}

		res := api.Res("timer")
		r, err := res.Delete(querystring)
		HandleError(err)

		if r.Raw.StatusCode != 205 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

	},
}

var timeCmd = &cobra.Command{
	Use:   "time",
	Short: "Manipulate time entries",
	Long:  `Subcommands for time allow you to list or manipulate time entries`,
}

var timelistCmd = &cobra.Command{
	Use:   "list",
	Short: "List time entries",
	Long:  `List time entries for a specific date`,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		resp := new(TimeEntryResponseArray)

		querystring := make(map[string]string)
		value, e := cmd.Flags().GetString("date")
		HandleError(e)
		querystring["date"] = value

		if impersonate != "" {
			querystring["user_id"] = impersonate
		}

		pe := timeParamHandler(&querystring)
		HandleError(pe)

		res := api.Res("time_entries", resp)
		r, err := res.Get(querystring)
		HandleError(err)

		if r.Raw.StatusCode != 200 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

		printArrayResponse(*resp)

	},
}

var timegetCmd = &cobra.Command{
	Use:   "get",
	Short: "Get a time entry specified by an id",
	Long:  `Returns a specific time entry, which is given as an argument to the command`,
	Run: func(cmd *cobra.Command, args []string) {

		if len(args) < (0 + 1) {
			HandleError(errors.New("argument 0 is required for this command"))
		}

		api := getAPI()

		resp := new(TimeEntryResponse)

		querystring := make(map[string]string)

		if impersonate != "" {
			querystring["user_id"] = impersonate
		}

		res := api.Res("time_entries", resp)
		r, err := res.Id(args[0]).Get(querystring)
		HandleError(err)

		if r.Raw.StatusCode != 200 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

		printResponse(*resp)

	},
}

var timecreateCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a time entry in the calendar",
	Long:  `Starts, Ends and the timer type ID are required to create a new timer entry`,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		resp := new(TimeEntryResponse)

		payload := new(TimeEntryPayload)

		// Payload renderer must have signature (cmd *cobra.Command, args []string, payload *TimeEntryPayload) (*TimeEntryPayload, error)
		err := fillRequiredTimeEntryData(cmd, args, payload)
		HandleError(err)
		res := api.Res("time_entries", resp)
		if impersonate != "" {
			querystring := make(map[string]string, 1)
			querystring["user_id"] = impersonate
			res.SetPayload(querystring)
		}
		r, err := res.Post(payload)
		HandleError(err)

		if r.Raw.StatusCode != 201 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

		printResponse(*resp)

	},
}

var timeupdateCmd = &cobra.Command{
	Use:   "update",
	Short: "Update a time entry",
	Long:  `Updates an entry by id, which is required`,
	Run: func(cmd *cobra.Command, args []string) {

		if len(args) < (0 + 1) {
			HandleError(errors.New("argument 0 is required for this command"))
		}

		api := getAPI()

		resp := new(TimeEntryResponse)

		payload := new(TimeEntryPayload)

		// Payload renderer must have signature (cmd *cobra.Command, args []string, payload *TimeEntryPayload) (*TimeEntryPayload, error)
		err := fillOptionalTimeEntryData(cmd, args, payload)
		HandleError(err)
		res := api.Res("time_entries", resp)
		if impersonate != "" {
			querystring := make(map[string]string, 1)
			querystring["user_id"] = impersonate
			res.SetPayload(querystring)
		}
		r, err := res.Id(args[0]).Patch(payload)
		HandleError(err)

		if r.Raw.StatusCode != 200 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

	},
}

var timedeleteCmd = &cobra.Command{
	Use:   "delete",
	Short: "Delete a time",
	Long:  `Deletes a time via it's id.`,
	Run: func(cmd *cobra.Command, args []string) {

		if len(args) < (0 + 1) {
			HandleError(errors.New("argument 0 is required for this command"))
		}

		api := getAPI()

		querystring := make(map[string]string)

		if impersonate != "" {
			querystring["user_id"] = impersonate
		}

		res := api.Res("time_entries")
		r, err := res.Id(args[0]).Delete(querystring)
		HandleError(err)

		if r.Raw.StatusCode != 204 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

	},
}

var projectsCmd = &cobra.Command{
	Use:   "projects",
	Short: "Get a list of all projects",
	Long:  ``,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		resp := new(ProjectResponse)

		querystring := make(map[string]string)

		if impersonate != "" {
			querystring["user_id"] = impersonate
		}

		res := api.Res("projects", resp)
		r, err := res.Get(querystring)
		HandleError(err)

		if r.Raw.StatusCode != 200 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

		printArrayResponse(*resp)

	},
}

var organizationCmd = &cobra.Command{
	Use:     "organization",
	Short:   "Get organization details",
	Aliases: []string{"organisation", "org"},
	Long:    `Returns the details of the organization as authorized by your token`,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		resp := new(OrgResponse)

		querystring := make(map[string]string)

		if impersonate != "" {
			querystring["user_id"] = impersonate
		}

		res := api.Res("organization/status", resp)
		r, err := res.Get(querystring)
		HandleError(err)

		if r.Raw.StatusCode != 200 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

		printArrayResponse(*resp)

	},
}

var absencesCmd = &cobra.Command{
	Use:   "absences",
	Short: "Get absences for a specific year",
	Long:  `If no year is supplied it will default to the current year`,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		resp := new(AbsenceResponseArray)

		querystring := make(map[string]string)
		value, e := cmd.Flags().GetString("year")
		HandleError(e)
		querystring["year"] = value

		if impersonate != "" {
			querystring["user_id"] = impersonate
		}

		pe := absenceParamHandler(&querystring)
		HandleError(pe)

		res := api.Res("absences", resp)
		r, err := res.Get(querystring)
		HandleError(err)

		if r.Raw.StatusCode != 200 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

		printArrayResponse(*resp)

	},
}

var usersCmd = &cobra.Command{
	Use:   "users",
	Short: "Retrieves all user you can manage (as admin or team leader)",
	Long:  ``,
	Run: func(cmd *cobra.Command, args []string) {

		api := getAPI()

		resp := new(UserResponse)

		querystring := make(map[string]string)

		if impersonate != "" {
			querystring["user_id"] = impersonate
		}

		res := api.Res("users", resp)
		r, err := res.Get(querystring)
		HandleError(err)

		if r.Raw.StatusCode != 200 && !skipStatusCheck {
			defer deferredBodyClose(r)
			bodyBytes, err := ioutil.ReadAll(r.Raw.Body)
			HandleError(err)
			HandleError(errors.New(string(bodyBytes)))
		}

		printArrayResponse(*resp)

	},
}

//Initialize commands and options
func init() {

	RootCmd.AddCommand(overviewCmd)

	RootCmd.AddCommand(timerCmd)
	timerCmd.PersistentFlags().Int("id", 1, "enter the id of the timer payload, should correspond to a timer type ID, default 1")
	timerCmd.PersistentFlags().Int("project", 0, "optionally enter the id of the project")
	timerCmd.PersistentFlags().String("start", "", "enter the start time in natural language (eg 15 minutes ago, 14:30)")
	timerCmd.PersistentFlags().String("note", "", "optional note to add to timer")

	timerCmd.AddCommand(timergetCmd)

	timerCmd.AddCommand(timertypesCmd)

	timerCmd.AddCommand(timerstartCmd)

	timerCmd.AddCommand(timerstopCmd)

	timerCmd.AddCommand(timercancelCmd)

	RootCmd.AddCommand(timeCmd)
	timeCmd.PersistentFlags().String("start", "", "enter the start date in natural language (eg Jan 15th, last Wednesday)")
	timeCmd.PersistentFlags().String("end", "", "enter the start date in natural language (eg Jan 15th, last Wednesday)")
	timeCmd.PersistentFlags().Int("time-id", 1, "enter the time type id. You can get these with the types command, defaults to 1 which is usually Arbeit")
	timeCmd.PersistentFlags().Int("project", 0, "optional project id")
	timeCmd.PersistentFlags().String("note", "", "optional note to add to the entry")

	timeCmd.AddCommand(timelistCmd)
	timelistCmd.Flags().StringP("date", "d", "", "enter the date in natural language (eg Jan 15th, last Wednesday, 01/12/18)")

	timeCmd.AddCommand(timegetCmd)

	timeCmd.AddCommand(timecreateCmd)

	timeCmd.AddCommand(timeupdateCmd)

	timeCmd.AddCommand(timedeleteCmd)

	RootCmd.AddCommand(projectsCmd)

	RootCmd.AddCommand(organizationCmd)

	RootCmd.AddCommand(absencesCmd)
	absencesCmd.Flags().String("year", "", "the year to look for")

	RootCmd.AddCommand(usersCmd)
}
